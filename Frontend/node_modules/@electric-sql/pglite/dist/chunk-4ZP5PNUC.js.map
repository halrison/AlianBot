{"version":3,"sources":["../src/base.ts"],"sourcesContent":["import { query as queryTemplate } from './templating.js'\nimport { parseDescribeStatementResults, parseResults } from './parse.js'\nimport {\n  type Serializer,\n  type Parser,\n  serializers,\n  parsers,\n  arraySerializer,\n  arrayParser,\n} from './types.js'\nimport type {\n  DebugLevel,\n  PGliteInterface,\n  Results,\n  Transaction,\n  QueryOptions,\n  ExecProtocolOptions,\n  ExecProtocolResult,\n  DescribeQueryResult,\n} from './interface.js'\n\nimport { serialize as serializeProtocol } from '@electric-sql/pg-protocol'\nimport {\n  RowDescriptionMessage,\n  ParameterDescriptionMessage,\n} from '@electric-sql/pg-protocol/messages'\n\nexport abstract class BasePGlite\n  implements Pick<PGliteInterface, 'query' | 'sql' | 'exec' | 'transaction'>\n{\n  serializers: Record<number | string, Serializer> = { ...serializers }\n  parsers: Record<number | string, Parser> = { ...parsers }\n  #arrayTypesInitialized = false\n\n  // # Abstract properties:\n  abstract debug: DebugLevel\n\n  // # Private properties:\n  #inTransaction = false\n\n  // # Abstract methods:\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  abstract execProtocol(\n    message: Uint8Array,\n    { syncToFs, onNotice }: ExecProtocolOptions,\n  ): Promise<ExecProtocolResult>\n\n  /**\n   * Execute a postgres wire protocol message directly without wrapping the response.\n   * Only use if `execProtocol()` doesn't suite your needs.\n   *\n   * **Warning:** This bypasses PGlite's protocol wrappers that manage error/notice messages,\n   * transactions, and notification listeners. Only use if you need to bypass these wrappers and\n   * don't intend to use the above features.\n   *\n   * @param message The postgres wire protocol message to execute\n   * @returns The direct message data response produced by Postgres\n   */\n  abstract execProtocolRaw(\n    message: Uint8Array,\n    { syncToFs }: ExecProtocolOptions,\n  ): Promise<Uint8Array>\n\n  /**\n   * Sync the database to the filesystem\n   * @returns Promise that resolves when the database is synced to the filesystem\n   */\n  abstract syncToFs(): Promise<void>\n\n  /**\n   * Handle a file attached to the current query\n   * @param file The file to handle\n   */\n  abstract _handleBlob(blob?: File | Blob): Promise<void>\n\n  /**\n   * Get the written file\n   */\n  abstract _getWrittenBlob(): Promise<File | Blob | undefined>\n\n  /**\n   * Cleanup the current file\n   */\n  abstract _cleanupBlob(): Promise<void>\n\n  abstract _checkReady(): Promise<void>\n  abstract _runExclusiveQuery<T>(fn: () => Promise<T>): Promise<T>\n  abstract _runExclusiveTransaction<T>(fn: () => Promise<T>): Promise<T>\n\n  // # Concrete implementations:\n\n  /**\n   * Initialize the array types\n   * The oid if the type of an element and the typarray is the oid of the type of the\n   * array.\n   * We extract these from the databaes then create the serializers/parsers for\n   * each type.\n   * This should be called at the end of #init() in the implementing class.\n   */\n  async _initArrayTypes() {\n    if (this.#arrayTypesInitialized) return\n    this.#arrayTypesInitialized = true\n\n    const types = await this.query<{ oid: number; typarray: number }>(`\n      SELECT b.oid, b.typarray\n      FROM pg_catalog.pg_type a\n      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem\n      WHERE a.typcategory = 'A'\n      GROUP BY b.oid, b.typarray\n      ORDER BY b.oid\n    `)\n\n    for (const type of types.rows) {\n      this.serializers[type.typarray] = (x) =>\n        arraySerializer(x, this.serializers[type.oid], type.typarray)\n      this.parsers[type.typarray] = (x) =>\n        arrayParser(x, this.parsers[type.oid], type.typarray)\n    }\n  }\n\n  async #execProtocolNoSync(\n    message: Uint8Array,\n    options: ExecProtocolOptions = {},\n  ): Promise<ExecProtocolResult> {\n    return await this.execProtocol(message, { ...options, syncToFs: false })\n  }\n\n  /**\n   * Execute a single SQL statement\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    await this._checkReady()\n    // We wrap the public query method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runQuery<T>(query, params, options)\n    })\n  }\n\n  /**\n   * Execute a single SQL statement like with {@link PGlite.query}, but with a\n   * templated statement where template values will be treated as parameters.\n   *\n   * You can use helpers from `/template` to further format the query with\n   * identifiers, raw SQL, and nested statements.\n   *\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   *\n   * @param query The query to execute with parameters as template values\n   * @returns The result of the query\n   *\n   * @example\n   * ```ts\n   * const results = await db.sql`SELECT * FROM ${identifier`foo`} WHERE id = ${id}`\n   * ```\n   */\n  async sql<T>(\n    sqlStrings: TemplateStringsArray,\n    ...params: any[]\n  ): Promise<Results<T>> {\n    const { query, params: actualParams } = queryTemplate(sqlStrings, ...params)\n    return await this.query(query, actualParams)\n  }\n\n  /**\n   * Execute a SQL query, this can have multiple statements.\n   * This uses the \"Simple Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @returns The result of the query\n   */\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    await this._checkReady()\n    // We wrap the public exec method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this._runExclusiveTransaction(async () => {\n      return await this.#runExec(query, options)\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runQuery<T>(\n    query: string,\n    params: any[] = [],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    return await this._runExclusiveQuery(async () => {\n      // We need to parse, bind and execute a query with parameters\n      this.#log('runQuery', query, params, options)\n      await this._handleBlob(options?.blob)\n\n      let results\n\n      try {\n        const { messages: parseResults } = await this.#execProtocolNoSync(\n          serializeProtocol.parse({ text: query, types: options?.paramTypes }),\n          options,\n        )\n\n        const dataTypeIDs = parseDescribeStatementResults(\n          (\n            await this.#execProtocolNoSync(\n              serializeProtocol.describe({ type: 'S' }),\n              options,\n            )\n          ).messages,\n        )\n\n        const values = params.map((param, i) => {\n          const oid = dataTypeIDs[i]\n          if (param === null || param === undefined) {\n            return null\n          }\n          const serialize = options?.serializers?.[oid] ?? this.serializers[oid]\n          if (serialize) {\n            return serialize(param)\n          } else {\n            return param.toString()\n          }\n        })\n\n        results = [\n          ...parseResults,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.bind({\n                values,\n              }),\n              options,\n            )\n          ).messages,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.describe({ type: 'P' }),\n              options,\n            )\n          ).messages,\n          ...(\n            await this.#execProtocolNoSync(\n              serializeProtocol.execute({}),\n              options,\n            )\n          ).messages,\n        ]\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n\n      await this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(results, this.parsers, options, blob)[0] as Results<T>\n    })\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runExec(\n    query: string,\n    options?: QueryOptions,\n  ): Promise<Array<Results>> {\n    return await this._runExclusiveQuery(async () => {\n      // No params so we can just send the query\n      this.#log('runExec', query, options)\n      await this._handleBlob(options?.blob)\n      let results\n      try {\n        results = (\n          await this.#execProtocolNoSync(\n            serializeProtocol.query(query),\n            options,\n          )\n        ).messages\n      } finally {\n        await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n      }\n      this._cleanupBlob()\n      if (!this.#inTransaction) {\n        await this.syncToFs()\n      }\n      const blob = await this._getWrittenBlob()\n      return parseResults(\n        results,\n        this.parsers,\n        options,\n        blob,\n      ) as Array<Results>\n    })\n  }\n\n  /**\n   * Describe a query\n   * @param query The query to describe\n   * @returns A description of the result types for the query\n   */\n  async describeQuery(\n    query: string,\n    options?: QueryOptions,\n  ): Promise<DescribeQueryResult> {\n    try {\n      await this.#execProtocolNoSync(\n        serializeProtocol.parse({ text: query, types: options?.paramTypes }),\n        options,\n      )\n\n      const describeResults = await this.#execProtocolNoSync(\n        serializeProtocol.describe({ type: 'S' }),\n        options,\n      )\n      const paramDescription = describeResults.messages.find(\n        (msg): msg is ParameterDescriptionMessage =>\n          msg.name === 'parameterDescription',\n      )\n      const resultDescription = describeResults.messages.find(\n        (msg): msg is RowDescriptionMessage => msg.name === 'rowDescription',\n      )\n\n      const queryParams =\n        paramDescription?.dataTypeIDs.map((dataTypeID) => ({\n          dataTypeID,\n          serializer: this.serializers[dataTypeID],\n        })) ?? []\n\n      const resultFields =\n        resultDescription?.fields.map((field) => ({\n          name: field.name,\n          dataTypeID: field.dataTypeID,\n          parser: this.parsers[field.dataTypeID],\n        })) ?? []\n\n      return { queryParams, resultFields }\n    } finally {\n      await this.#execProtocolNoSync(serializeProtocol.sync(), options)\n    }\n  }\n\n  /**\n   * Execute a transaction\n   * @param callback A callback function that takes a transaction object\n   * @returns The result of the transaction\n   */\n  async transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined> {\n    await this._checkReady()\n    return await this._runExclusiveTransaction(async () => {\n      await this.#runExec('BEGIN')\n      this.#inTransaction = true\n\n      // Once a transaction is closed, we throw an error if it's used again\n      let closed = false\n      const checkClosed = () => {\n        if (closed) {\n          throw new Error('Transaction is closed')\n        }\n      }\n\n      const tx: Transaction = {\n        query: async <T>(\n          query: string,\n          params?: any[],\n          options?: QueryOptions,\n        ): Promise<Results<T>> => {\n          checkClosed()\n          return await this.#runQuery(query, params, options)\n        },\n        sql: async <T>(\n          sqlStrings: TemplateStringsArray,\n          ...params: any[]\n        ): Promise<Results<T>> => {\n          const { query, params: actualParams } = queryTemplate(\n            sqlStrings,\n            ...params,\n          )\n          return await this.#runQuery(query, actualParams)\n        },\n        exec: async (\n          query: string,\n          options?: QueryOptions,\n        ): Promise<Array<Results>> => {\n          checkClosed()\n          return await this.#runExec(query, options)\n        },\n        rollback: async () => {\n          checkClosed()\n          // Rollback and set the closed flag to prevent further use of this\n          // transaction\n          await this.#runExec('ROLLBACK')\n          closed = true\n        },\n        get closed() {\n          return closed\n        },\n      }\n\n      try {\n        const result = await callback(tx)\n        if (!closed) {\n          closed = true\n          await this.#runExec('COMMIT')\n        }\n        this.#inTransaction = false\n        return result\n      } catch (e) {\n        if (!closed) {\n          await this.#runExec('ROLLBACK')\n        }\n        this.#inTransaction = false\n        throw e\n      }\n    })\n  }\n\n  /**\n   * Internal log function\n   */\n  #log(...args: any[]) {\n    if (this.debug > 0) {\n      console.log(...args)\n    }\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","_arrayTypesInitialized","_inTransaction","_BasePGlite_instances","execProtocolNoSync_fn","runQuery_fn","runExec_fn","log_fn","BasePGlite","__privateAdd","serializers","parsers","__privateGet","__privateSet","types","type","x","arraySerializer","arrayParser","query","params","options","__privateMethod","sqlStrings","actualParams","serialize","describeResults","paramDescription","msg","resultDescription","queryParams","dataTypeID","resultFields","field","callback","closed","checkClosed","tx","result","e","message","results","parseResults","dataTypeIDs","parseDescribeStatementResults","values","param","i","oid","blob","args"]}